#!/usr/bin/env python3

import argparse
import datetime
import json
import logging
import os
import sys
import time
import vlabconfig

"""
Parses the access.log file generated by shell.py to collect statistics about how the VLAB is being used.

Ian Gray, 2017
"""

log = logging.getLogger()
log.setLevel(logging.INFO)
ch = logging.StreamHandler(sys.stdout)
ch.setLevel(logging.INFO)
log.addHandler(ch)


def build_parser():
	main_parser = argparse.ArgumentParser(description='VLAB log parsing')
	main_parser.add_argument('-f', '--logfile', nargs=1, default=["/vlab/log/access.log"], help='The VLAB access log')
	main_parser.add_argument('-c', '--configfile', nargs=1, default=["/vlab/vlab.conf"], help='The VLAB config file')
	return main_parser


def parseline(line, stats):
	"""
	Current log format is 4 fields, separated by semicolons
	<Timestamp> ; <Level> ; <Originating script> ; <Message>

	Timestamp is format %Y-%m-%d %H:%M:%S,%f. Example: 2017-04-02 22:58:10,492
	Level is 'DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL'
	Originating script is the basename of the VLAB script which output the message
	"""
	fields = line.split(';')
	if len(fields) == 4:
		if fields[2].strip() == "shell.py":
			# Read in the timestamp and convert to seconds since the epoch
			sse = fields[0].strip()
			try:
				sse = time.strptime(sse, "%Y-%m-%d %H:%M:%S,%f")
				sse = time.mktime(sse)
			except ValueError:
				return None

			if stats['earliest_date'] is None:
				stats['earliest_date'] = datetime.date.fromtimestamp(sse)

			msg = fields[3].strip()

			# Messages from shell.py are of the following:
			# LOCK: username, boardclass, 3 remaining in set
			# RELEASE: username, boardclass
			# NOFREEBOARDS: username, boardclass

			msg = msg.split(':')
			if len(msg) == 2:
				params = msg[1].strip().split(',')

				username = params[0].strip()
				boardclass = params[1].strip()

				# Because it is only possible for a user to have one board of each boardclass locked at
				# any one time then we can use the combination of those as the map key
				lock_key = username + boardclass

				if msg[0].strip() == "LOCK":
					# Parse the number of boards from that class remaining
					try:
						if len(params) == 3:
							rem_str = params[2].strip()
							if rem_str.endswith(" remaining in set"):
								num_remaining = int(rem_str[:-len(" remaining in set")])
								# Record the lowest seen value for this
								if boardclass in stats['minimum_available'] \
								   and stats['minimum_available'][boardclass] is not None:
									if stats['minimum_available'][boardclass] > num_remaining:
										stats['minimum_available'][boardclass] = num_remaining
								else:
									stats['minimum_available'][boardclass] = num_remaining
						else:
							# We didnt have 3 parameters in the lock message
							return False
					except ValueError:
						# The boards remaining parameter didn't parse to an integer
						return False

					# Now record the lock
					stats['locks'][lock_key] = sse
					if boardclass in stats['total_lock_counts']:
						stats['total_lock_counts'][boardclass] = stats['total_lock_counts'][boardclass] + 1
					else:
						stats['total_lock_counts'][boardclass] = 1

				elif msg[0].strip() == "RELEASE":
					if lock_key in stats['locks']:
						duration = sse - stats['locks'][lock_key]
						if boardclass in stats['average_locktime_secs'] \
						   and stats['average_locktime_secs'][boardclass] is not None:
							stats['average_locktime_secs'][boardclass] = \
								(stats['average_locktime_secs'][boardclass] + duration) / 2
						else:
							stats['average_locktime_secs'][boardclass] = duration

						if username in stats['average_user_locktime_secs'] \
						   and stats['average_user_locktime_secs'][username] is not None:
							stats['average_user_locktime_secs'][username] = \
								(stats['average_user_locktime_secs'][username] + duration) / 2
						else:
							stats['average_user_locktime_secs'][username] = duration

						del (stats['locks'][lock_key])

					else:
						# Releasing a board that isn't locked
						# This could happen if the log fragment we are parsing starts midway through a usage session
						# We can just ignore it
						pass

			else:
				# There was more than one colon in the message
				return False

	return None


def main():
	main_parser = build_parser()
	args = main_parser.parse_args()

	if not os.path.isfile(args.logfile[0]):
		log.critical("Cannot open file: {}".format(args.logfile[0]))
		sys.exit(1)

	# Set up our statistics
	stats = {
		'locks': {},
		'minimum_available': {},
		'average_locktime_secs': {},
		'average_user_locktime_secs': {},
		'total_lock_counts': {},
		'earliest_date': None
	}

	if os.path.isfile(args.configfile[0]):
		try:
			# Open the config file and parse it
			config = vlabconfig.open_log(log, args.configfile[0])

			for user in config['users']:
				stats['average_user_locktime_secs'][user] = None

			for board in config['boards'].keys():
				stats['average_locktime_secs'][config['boards'][board]['class']] = None
				stats['total_lock_counts'][config['boards'][board]['class']] = 0

		except (IOError, ValueError) as e:
			# We can still get useful stats from what is in the log, but we note this error
			log.critical("Error whilst parsing VLAB config file {}. {}".format(args.configfile[0], e))

	# In case the logfile is enormous, we can use tail to give us a more sensible amount to work with
	data = os.popen('tail -n 5000 {}'.format(args.logfile[0])).read()
	data = data.split('\n')
	for line in data:
		parseline(line, stats)

	stats['earliest_date'] = stats['earliest_date'].strftime("%Y-%m-%d %H:%M:%S")

	del (stats['locks'])
	print(json.dumps(stats, indent=4))


if __name__ == '__main__':
	main()
